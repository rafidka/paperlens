<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PaperLens - AI-Powered Arxiv Paper Reader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
        }

        .setup-panel {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .api-keys {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .api-key-group {
            display: flex;
            flex-direction: column;
        }

        .api-key-group label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #2c3e50;
        }

        .api-key-group input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .paper-input {
            margin-bottom: 20px;
        }

        .paper-input label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #2c3e50;
        }

        .paper-input input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .content-area {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            background: #27ae60;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .paper-content {
            max-height: 400px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #e9ecef;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .qa-section {
            margin-top: 20px;
        }

        .qa-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            resize: vertical;
            min-height: 80px;
        }

        .qa-history {
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #e9ecef;
            margin-bottom: 15px;
        }

        .qa-item {
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .qa-question {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .qa-answer {
            color: #555;
            line-height: 1.5;
        }

        .tabs {
            display: flex;
            background: #ecf0f1;
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: transparent;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: #3498db;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .api-keys {
                grid-template-columns: 1fr;
            }

            .button-group {
                flex-direction: column;
            }

            .tabs {
                flex-direction: column;
            }
        }

        .library-panel {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .library-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .library-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .library-item:hover {
            background: #e9ecef;
            border-color: #3498db;
        }

        .library-item.cached {
            border-left: 4px solid #27ae60;
        }

        .library-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
            font-size: 14px;
            line-height: 1.3;
        }

        .library-id {
            color: #7f8c8d;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .library-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: #95a5a6;
        }

        .cache-badges {
            display: flex;
            gap: 3px;
        }

        .cache-badge {
            background: #3498db;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
        }

        .delete-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
        }

        .delete-btn:hover {
            background: #c0392b;
        }

        .cache-status {
            font-size: 12px;
            margin-left: 10px;
            padding: 2px 8px;
            border-radius: 3px;
        }

        .cache-status.cached {
            background: #d4edda;
            color: #155724;
        }

        .cache-status.not-cached {
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ”¬ PaperLens</h1>
            <p>AI-Powered Arxiv Paper Reader with Summary, Q&A, and Readability Enhancement</p>
        </div>

        <div class="library-panel">
            <h3>ðŸ“š Paper Library</h3>
            <div class="button-group">
                <button class="btn btn-secondary" onclick="showLibrary()">Show Cached Papers</button>
                <button class="btn btn-secondary" onclick="clearCache()">Clear Cache</button>
            </div>
            <div id="library-container" style="display: none;">
                <div id="library-grid" class="library-grid"></div>
            </div>
        </div>

        <div class="setup-panel">
            <h3>Setup</h3>
            <div class="api-keys">
                <div class="api-key-group">
                    <label for="openai-key">OpenAI API Key:</label>
                    <input type="password" id="openai-key" placeholder="sk-...">
                </div>
                <div class="api-key-group">
                    <label for="cohere-key">Cohere API Key:</label>
                    <input type="password" id="cohere-key" placeholder="Your Cohere API key">
                </div>
                <div class="api-key-group">
                    <label for="anthropic-key">Anthropic API Key:</label>
                    <input type="password" id="anthropic-key" placeholder="sk-ant-...">
                </div>
            </div>

            <div class="paper-input">
                <label for="arxiv-url">Arxiv Paper URL or ID:</label>
                <input type="text" id="arxiv-url" placeholder="https://arxiv.org/abs/2301.00001 or 2301.00001">
                <span id="cache-status" class="cache-status" style="display: none;"></span>
            </div>

            <div class="button-group">
                <button class="btn btn-primary" onclick="loadPaper()">Load Paper</button>
                <button class="btn btn-secondary" onclick="clearAll()">Clear All</button>
            </div>
        </div>

        <div id="paper-section" class="content-area" style="display: none;">
            <h3 id="paper-title">Paper Title</h3>
            <div class="tabs">
                <button class="tab active" onclick="showTab('summary')">Summary</button>
                <button class="tab" onclick="showTab('concepts')">Key Concepts</button>
                <button class="tab" onclick="showTab('readable')">Readable Version</button>
                <button class="tab" onclick="showTab('qa')">Q&A</button>
                <button class="tab" onclick="showTab('original')">Original</button>
            </div>

            <div id="summary-tab" class="tab-content active">
                <h4>Paper Summary</h4>
                <button class="btn btn-success" onclick="generateSummary()">Generate Summary</button>
                <div id="summary-content" class="paper-content" style="display: none;"></div>
            </div>

            <div id="concepts-tab" class="tab-content">
                <h4>Key Concepts</h4>
                <button class="btn btn-success" onclick="extractConcepts()">Extract Key Concepts</button>
                <div id="concepts-content" class="paper-content" style="display: none;"></div>
            </div>

            <div id="readable-tab" class="tab-content">
                <h4>Readable Version (Text-to-Speech Optimized)</h4>
                <button class="btn btn-success" onclick="generateReadable()">Generate Readable Version</button>
                <div id="readable-content" class="paper-content" style="display: none;"></div>
            </div>

            <div id="qa-tab" class="tab-content">
                <h4>Q&A</h4>
                <div id="qa-history" class="qa-history" style="display: none;"></div>
                <textarea id="qa-input" class="qa-input" placeholder="Ask a question about the paper..."></textarea>
                <button class="btn btn-success" onclick="askQuestion()">Ask Question</button>
            </div>

            <div id="original-tab" class="tab-content">
                <h4>Original Paper Content</h4>
                <div id="original-content" class="paper-content"></div>
            </div>
        </div>

        <div id="loading" class="content-area loading" style="display: none;">
            <div class="spinner"></div>
            <p>Loading paper content...</p>
        </div>

        <div id="error-container"></div>
    </div>

    <script>
        let currentPaper = null;
        let qaHistory = [];
        const CACHE_PREFIX = 'paperlens_';
        const LIBRARY_KEY = 'paperlens_library';

        function showError(message) {
            const container = document.getElementById('error-container');
            container.innerHTML = `<div class="error">${message}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }

        function showSuccess(message) {
            const container = document.getElementById('error-container');
            container.innerHTML = `<div class="success">${message}</div>`;
            setTimeout(() => container.innerHTML = '', 3000);
        }

        function showLoading(show = true) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('paper-section').style.display = show ? 'none' : 'block';
        }

        function extractArxivId(input) {
            input = input.trim();

            // If it's already just an ID
            if (/^\d{4}\.\d{4,5}$/.test(input)) {
                return input;
            }

            // Extract from URL
            const match = input.match(/(?:arxiv\.org\/abs\/|arxiv:)(\d{4}\.\d{4,5})/);
            return match ? match[1] : null;
        }

        function getCacheKey(arxivId) {
            return CACHE_PREFIX + arxivId;
        }

        function getLibrary() {
            const library = localStorage.getItem(LIBRARY_KEY);
            return library ? JSON.parse(library) : [];
        }

        function updateLibrary(paperData) {
            let library = getLibrary();
            const existingIndex = library.findIndex(p => p.id === paperData.id);

            if (existingIndex >= 0) {
                library[existingIndex] = { ...library[existingIndex], ...paperData, lastAccessed: Date.now() };
            } else {
                library.push({ ...paperData, lastAccessed: Date.now() });
            }

            localStorage.setItem(LIBRARY_KEY, JSON.stringify(library));
        }

        function removeFromLibrary(arxivId) {
            let library = getLibrary();
            library = library.filter(p => p.id !== arxivId);
            localStorage.setItem(LIBRARY_KEY, JSON.stringify(library));
        }

        function cachePaper(paperData) {
            const cacheKey = getCacheKey(paperData.id);
            const cacheData = {
                ...paperData,
                cachedAt: Date.now(),
                summary: currentPaper?.summary || null,
                concepts: currentPaper?.concepts || null,
                readable: currentPaper?.readable || null,
                qaHistory: qaHistory.length > 0 ? qaHistory : null
            };

            localStorage.setItem(cacheKey, JSON.stringify(cacheData));
            updateLibrary(paperData);
        }

        function getCachedPaper(arxivId) {
            const cacheKey = getCacheKey(arxivId);
            const cached = localStorage.getItem(cacheKey);
            return cached ? JSON.parse(cached) : null;
        }

        function deleteCachedPaper(arxivId) {
            const cacheKey = getCacheKey(arxivId);
            localStorage.removeItem(cacheKey);
            removeFromLibrary(arxivId);
        }

        function updateCacheStatus(arxivId) {
            const statusElement = document.getElementById('cache-status');
            if (!arxivId) {
                statusElement.style.display = 'none';
                return;
            }

            const cached = getCachedPaper(arxivId);
            statusElement.style.display = 'inline-block';

            if (cached) {
                statusElement.className = 'cache-status cached';
                statusElement.textContent = 'âœ“ Cached';
            } else {
                statusElement.className = 'cache-status not-cached';
                statusElement.textContent = 'â—‹ Not cached';
            }
        }

        async function loadPaper(fromCache = false) {
            const arxivInput = document.getElementById('arxiv-url').value;
            const arxivId = extractArxivId(arxivInput);

            if (!arxivId) {
                showError('Please enter a valid Arxiv URL or ID (e.g., 2301.00001)');
                return;
            }

            // Check cache first
            const cached = getCachedPaper(arxivId);

            if (cached && fromCache !== false) {
                loadFromCache(cached);
                return;
            }

            showLoading(true);

            try {
                // Use Ar5iv service to get HTML version
                const ar5ivUrl = `https://ar5iv.labs.arxiv.org/html/${arxivId}`;
                const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(ar5ivUrl)}`);

                if (!response.ok) {
                    throw new Error('Failed to fetch paper from Ar5iv');
                }

                const data = await response.json();
                const htmlContent = data.contents;

                // Parse the HTML to extract text content
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');

                // Get title
                const title = doc.querySelector('h1.ltx_title')?.textContent ||
                    doc.querySelector('title')?.textContent ||
                    `Arxiv Paper ${arxivId}`;

                // Extract main content (remove nav, header, footer elements)
                const mainContent = doc.querySelector('article') || doc.querySelector('main') || doc.body;

                // Remove unwanted elements
                const unwantedSelectors = ['nav', 'header', 'footer', '.ltx_navigation', '.ltx_page_header', '.ltx_page_footer'];
                unwantedSelectors.forEach(selector => {
                    const elements = mainContent.querySelectorAll(selector);
                    elements.forEach(el => el.remove());
                });

                // Get clean text content
                const textContent = mainContent.textContent || mainContent.innerText;

                currentPaper = {
                    id: arxivId,
                    title: title.trim(),
                    content: textContent.trim()
                };

                // Cache the paper
                cachePaper(currentPaper);

                document.getElementById('paper-title').textContent = currentPaper.title;
                document.getElementById('original-content').textContent = currentPaper.content;

                showLoading(false);
                showSuccess('Paper loaded and cached successfully!');

                // Reset all generated content
                resetGeneratedContent();
                updateCacheStatus(arxivId);

            } catch (error) {
                showLoading(false);
                showError(`Error loading paper: ${error.message}`);
                console.error('Error:', error);
            }
        }

        function loadFromCache(cached) {
            currentPaper = {
                id: cached.id,
                title: cached.title,
                content: cached.content,
                summary: cached.summary,
                concepts: cached.concepts,
                readable: cached.readable
            };

            qaHistory = cached.qaHistory || [];

            document.getElementById('paper-title').textContent = currentPaper.title;
            document.getElementById('original-content').textContent = currentPaper.content;

            // Load cached AI-generated content
            if (cached.summary) {
                document.getElementById('summary-content').textContent = cached.summary;
                document.getElementById('summary-content').style.display = 'block';
            }

            if (cached.concepts) {
                document.getElementById('concepts-content').textContent = cached.concepts;
                document.getElementById('concepts-content').style.display = 'block';
            }

            if (cached.readable) {
                document.getElementById('readable-content').textContent = cached.readable;
                document.getElementById('readable-content').style.display = 'block';
            }

            updateQAHistory();

            document.getElementById('paper-section').style.display = 'block';
            showSuccess('Paper loaded from cache!');
            updateCacheStatus(cached.id);
        }

        function resetGeneratedContent() {
            ['summary-content', 'concepts-content', 'readable-content'].forEach(id => {
                document.getElementById(id).style.display = 'none';
                document.getElementById(id).textContent = '';
            });

            qaHistory = [];
            document.getElementById('qa-history').style.display = 'none';
            document.getElementById('qa-history').innerHTML = '';
            document.getElementById('qa-input').value = '';
        }

        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab content
            document.getElementById(`${tabName}-tab`).classList.add('active');

            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        function getSelectedProvider() {
            const openaiKey = document.getElementById('openai-key').value.trim();
            const cohereKey = document.getElementById('cohere-key').value.trim();
            const anthropicKey = document.getElementById('anthropic-key').value.trim();

            if (openaiKey) return { provider: 'openai', key: openaiKey };
            if (anthropicKey) return { provider: 'anthropic', key: anthropicKey };
            if (cohereKey) return { provider: 'cohere', key: cohereKey };

            return null;
        }

        async function callLLM(messages, provider, apiKey) {
            if (provider === 'openai') {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: messages,
                        max_tokens: 4000
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;

            } else if (provider === 'anthropic') {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-5-sonnet-20241022',
                        max_tokens: 4000,
                        messages: messages.filter(m => m.role !== 'system').map(m => ({
                            role: m.role === 'assistant' ? 'assistant' : 'user',
                            content: m.content
                        })),
                        system: messages.find(m => m.role === 'system')?.content || ''
                    })
                });

                if (!response.ok) {
                    throw new Error(`Anthropic API error: ${response.status}`);
                }

                const data = await response.json();
                return data.content[0].text;

            } else if (provider === 'cohere') {
                // Convert messages to Cohere format
                const systemMessage = messages.find(m => m.role === 'system');
                const userMessages = messages.filter(m => m.role !== 'system');
                const lastMessage = userMessages[userMessages.length - 1];

                const response = await fetch('https://api.cohere.ai/v1/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'command-r-plus',
                        message: lastMessage.content,
                        preamble: systemMessage?.content || '',
                        max_tokens: 4000
                    })
                });

                if (!response.ok) {
                    throw new Error(`Cohere API error: ${response.status}`);
                }

                const data = await response.json();
                return data.text;
            }
        }

        async function generateSummary() {
            if (!currentPaper) {
                showError('Please load a paper first');
                return;
            }

            const llmConfig = getSelectedProvider();
            if (!llmConfig) {
                showError('Please enter an API key for at least one provider');
                return;
            }

            const button = event.target;
            button.disabled = true;
            button.textContent = 'Generating...';

            try {
                const messages = [
                    {
                        role: 'system',
                        content: 'You are an expert at summarizing academic papers. Provide a clear, comprehensive summary that covers the main contributions, methodology, and findings.'
                    },
                    {
                        role: 'user',
                        content: `Please provide a detailed summary of this academic paper:\n\nTitle: ${currentPaper.title}\n\nContent:\n${currentPaper.content.substring(0, 15000)}`
                    }
                ];

                const summary = await callLLM(messages, llmConfig.provider, llmConfig.key);

                currentPaper.summary = summary;
                document.getElementById('summary-content').textContent = summary;
                document.getElementById('summary-content').style.display = 'block';

                // Update cache
                cachePaper(currentPaper);

            } catch (error) {
                showError(`Error generating summary: ${error.message}`);
            } finally {
                button.disabled = false;
                button.textContent = 'Generate Summary';
            }
        }

        async function extractConcepts() {
            if (!currentPaper) {
                showError('Please load a paper first');
                return;
            }

            const llmConfig = getSelectedProvider();
            if (!llmConfig) {
                showError('Please enter an API key for at least one provider');
                return;
            }

            const button = event.target;
            button.disabled = true;
            button.textContent = 'Extracting...';

            try {
                const messages = [
                    {
                        role: 'system',
                        content: 'You are an expert at extracting key concepts from academic papers. Identify and explain the most important concepts, terms, methods, and ideas presented in the paper. Format your response as a clear list with explanations.'
                    },
                    {
                        role: 'user',
                        content: `Please extract and explain the key concepts from this academic paper:\n\nTitle: ${currentPaper.title}\n\nContent:\n${currentPaper.content.substring(0, 15000)}`
                    }
                ];

                const concepts = await callLLM(messages, llmConfig.provider, llmConfig.key);

                currentPaper.concepts = concepts;
                document.getElementById('concepts-content').textContent = concepts;
                document.getElementById('concepts-content').style.display = 'block';

                // Update cache
                cachePaper(currentPaper);

            } catch (error) {
                showError(`Error extracting concepts: ${error.message}`);
            } finally {
                button.disabled = false;
                button.textContent = 'Extract Key Concepts';
            }
        }

        async function generateReadable() {
            if (!currentPaper) {
                showError('Please load a paper first');
                return;
            }

            const llmConfig = getSelectedProvider();
            if (!llmConfig) {
                showError('Please enter an API key for at least one provider');
                return;
            }

            const button = event.target;
            button.disabled = true;
            button.textContent = 'Generating...';

            try {
                const systemPrompt = `You are an AI readability editor preparing technical prose for high-quality text-to-speech narration.

**Goals**
â€¢ Preserve every fact, definition, symbol, and equation exactly.
â€¢ Make only SMALL edits that improve oral flow and comprehension.
â€¢ Never add personal commentary or new content.

**Edit Rules**
1. Convert inline math symbols to spoken words ("âˆ€" â†’ "for all", "â‰ˆ" â†’ "approximately").
2. For equations, try to summarize them since listening to symbols being read out is not quite easy to follow.
3. Replace citation brackets like "[12]" with "(reference 12)" or remove them if they disrupt flow.
4. For each displayed equation:
   â€¢ Prepend "Equation (n):" (use the existing number if present, otherwise number sequentially).
   â€¢ Append a â‰¤20-word plain-English gloss unless the sentence right after already explains it.
5. Keep section headings, figure captions, table captions, and bullet lists verbatim.
6. Do **not** alter variable names, numeric values, or claim meanings.
7. Output only the revised textâ€”no explanations, markdown, or extra headings.`;

                const messages = [
                    {
                        role: 'system',
                        content: systemPrompt
                    },
                    {
                        role: 'user',
                        content: `Please edit this academic paper for text-to-speech narration:\n\n${currentPaper.content.substring(0, 15000)}`
                    }
                ];

                const readableVersion = await callLLM(messages, llmConfig.provider, llmConfig.key);

                currentPaper.readable = readableVersion;
                document.getElementById('readable-content').textContent = readableVersion;
                document.getElementById('readable-content').style.display = 'block';

                // Update cache
                cachePaper(currentPaper);

            } catch (error) {
                showError(`Error generating readable version: ${error.message}`);
            } finally {
                button.disabled = false;
                button.textContent = 'Generate Readable Version';
            }
        }

        async function askQuestion() {
            const question = document.getElementById('qa-input').value.trim();

            if (!question) {
                showError('Please enter a question');
                return;
            }

            if (!currentPaper) {
                showError('Please load a paper first');
                return;
            }

            const llmConfig = getSelectedProvider();
            if (!llmConfig) {
                showError('Please enter an API key for at least one provider');
                return;
            }

            const button = event.target;
            button.disabled = true;
            button.textContent = 'Asking...';

            try {
                const messages = [
                    {
                        role: 'system',
                        content: 'You are an expert at answering questions about academic papers. Provide accurate, detailed answers based on the paper content. If the information is not in the paper, clearly state that.'
                    },
                    {
                        role: 'user',
                        content: `Based on this academic paper, please answer the following question:\n\nPaper Title: ${currentPaper.title}\n\nPaper Content:\n${currentPaper.content.substring(0, 15000)}\n\nQuestion: ${question}`
                    }
                ];

                const answer = await callLLM(messages, llmConfig.provider, llmConfig.key);

                qaHistory.push({ question, answer });
                updateQAHistory();

                // Update cache with new Q&A
                if (currentPaper) {
                    cachePaper(currentPaper);
                }

                document.getElementById('qa-input').value = '';

            } catch (error) {
                showError(`Error getting answer: ${error.message}`);
            } finally {
                button.disabled = false;
                button.textContent = 'Ask Question';
            }
        }

        function updateQAHistory() {
            const historyDiv = document.getElementById('qa-history');

            if (qaHistory.length === 0) {
                historyDiv.style.display = 'none';
                return;
            }

            historyDiv.style.display = 'block';
            historyDiv.innerHTML = qaHistory.map(item => `
                <div class="qa-item">
                    <div class="qa-question">Q: ${item.question}</div>
                    <div class="qa-answer">A: ${item.answer}</div>
                </div>
            `).join('');

            historyDiv.scrollTop = historyDiv.scrollHeight;
        }

        function clearAll() {
            currentPaper = null;
            qaHistory = [];

            document.getElementById('arxiv-url').value = '';
            document.getElementById('paper-section').style.display = 'none';
            document.getElementById('library-container').style.display = 'none';

            resetGeneratedContent();
            updateCacheStatus(null);

            showSuccess('All content cleared');
        }

        function showLibrary() {
            const container = document.getElementById('library-container');
            const grid = document.getElementById('library-grid');

            if (container.style.display === 'block') {
                container.style.display = 'none';
                return;
            }

            const library = getLibrary();

            if (library.length === 0) {
                grid.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #7f8c8d; padding: 20px;">No cached papers found</p>';
            } else {
                grid.innerHTML = library
                    .sort((a, b) => b.lastAccessed - a.lastAccessed)
                    .map(paper => {
                        const cached = getCachedPaper(paper.id);
                        const badges = [];

                        if (cached?.summary) badges.push('Sum');
                        if (cached?.concepts) badges.push('Con');
                        if (cached?.readable) badges.push('Read');
                        if (cached?.qaHistory?.length > 0) badges.push(`Q&A(${cached.qaHistory.length})`);

                        return `
                            <div class="library-item cached" onclick="loadCachedPaper('${paper.id}')">
                                <div class="library-title">${paper.title}</div>
                                <div class="library-id">ID: ${paper.id}</div>
                                <div class="library-meta">
                                    <div class="cache-badges">
                                        ${badges.map(badge => `<span class="cache-badge">${badge}</span>`).join('')}
                                    </div>
                                    <button class="delete-btn" onclick="event.stopPropagation(); deletePaper('${paper.id}');">Delete</button>
                                </div>
                            </div>
                        `;
                    }).join('');
            }

            container.style.display = 'block';
        }

        function loadCachedPaper(arxivId) {
            document.getElementById('arxiv-url').value = arxivId;
            const cached = getCachedPaper(arxivId);
            if (cached) {
                loadFromCache(cached);
                document.getElementById('library-container').style.display = 'none';
            }
        }

        function deletePaper(arxivId) {
            if (confirm(`Delete cached paper ${arxivId}?`)) {
                deleteCachedPaper(arxivId);
                showLibrary(); // Refresh the library view
                showSuccess('Paper deleted from cache');
            }
        }

        function clearCache() {
            if (confirm('Clear all cached papers? This cannot be undone.')) {
                const library = getLibrary();
                library.forEach(paper => {
                    localStorage.removeItem(getCacheKey(paper.id));
                });
                localStorage.removeItem(LIBRARY_KEY);

                document.getElementById('library-container').style.display = 'none';
                showSuccess('Cache cleared successfully');
            }
        }

        // Handle Enter key in Q&A input
        document.getElementById('qa-input').addEventListener('keydown', function (e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                askQuestion();
            }
        });

        // Handle Enter key in Arxiv URL input
        document.getElementById('arxiv-url').addEventListener('keydown', function (e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                loadPaper();
            }
        });

        // Update cache status when URL changes
        document.getElementById('arxiv-url').addEventListener('input', function (e) {
            const arxivId = extractArxivId(e.target.value);
            updateCacheStatus(arxivId);
        });

        // Initialize cache status on page load
        document.addEventListener('DOMContentLoaded', function () {
            updateCacheStatus(null);
        });
    </script>
</body>

</html>